// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import "encoding/json"
import "fmt"
import "reflect"

type Blocks []struct {
	// BoundingBox of a block
	BoundingBox BlocksElemBoundingBox `json:"boundingBox" yaml:"boundingBox" mapstructure:"boundingBox"`

	// Default state id
	DefaultState *int `json:"defaultState,omitempty" yaml:"defaultState,omitempty" mapstructure:"defaultState,omitempty"`

	// true if a block is diggable
	Diggable bool `json:"diggable" yaml:"diggable" mapstructure:"diggable"`

	// The display name of a block
	DisplayName string `json:"displayName" yaml:"displayName" mapstructure:"displayName"`

	// Drops corresponds to the JSON schema field "drops".
	Drops []interface{} `json:"drops" yaml:"drops" mapstructure:"drops"`

	// Light emitted by that block
	EmitLight int `json:"emitLight" yaml:"emitLight" mapstructure:"emitLight"`

	// Light filtered by that block
	FilterLight int `json:"filterLight" yaml:"filterLight" mapstructure:"filterLight"`

	// Hardness of a block
	Hardness *float64 `json:"hardness" yaml:"hardness" mapstructure:"hardness"`

	// Using one of these tools is required to harvest a block, without that you get a
	// 3.33x time penalty.
	HarvestTools BlocksElemHarvestTools `json:"harvestTools,omitempty" yaml:"harvestTools,omitempty" mapstructure:"harvestTools,omitempty"`

	// The unique identifier for a block
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// Material of a block
	Material *string `json:"material,omitempty" yaml:"material,omitempty" mapstructure:"material,omitempty"`

	// Maximum state id
	MaxStateId *int `json:"maxStateId,omitempty" yaml:"maxStateId,omitempty" mapstructure:"maxStateId,omitempty"`

	// Minimum state id
	MinStateId *int `json:"minStateId,omitempty" yaml:"minStateId,omitempty" mapstructure:"minStateId,omitempty"`

	// The name of a block
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Blast resistance
	Resistance *float64 `json:"resistance,omitempty" yaml:"resistance,omitempty" mapstructure:"resistance,omitempty"`

	// Stack size for a block
	StackSize int `json:"stackSize" yaml:"stackSize" mapstructure:"stackSize"`

	// States corresponds to the JSON schema field "states".
	States []BlocksElemStatesElem `json:"states,omitempty" yaml:"states,omitempty" mapstructure:"states,omitempty"`

	// true if a block is transparent
	Transparent bool `json:"transparent" yaml:"transparent" mapstructure:"transparent"`

	// Variations corresponds to the JSON schema field "variations".
	Variations []BlocksElemVariationsElem `json:"variations,omitempty" yaml:"variations,omitempty" mapstructure:"variations,omitempty"`
}

type BlocksElemBoundingBox string

const BlocksElemBoundingBoxBlock BlocksElemBoundingBox = "block"
const BlocksElemBoundingBoxEmpty BlocksElemBoundingBox = "empty"

var enumValues_BlocksElemBoundingBox = []interface{}{
	"block",
	"empty",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlocksElemBoundingBox) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlocksElemBoundingBox {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlocksElemBoundingBox, v)
	}
	*j = BlocksElemBoundingBox(v)
	return nil
}

// Using one of these tools is required to harvest a block, without that you get a
// 3.33x time penalty.
type BlocksElemHarvestTools map[string]interface{}

type BlocksElemStatesElem struct {
	// The name of the property
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The number of possible values
	NumValues float64 `json:"num_values" yaml:"num_values" mapstructure:"num_values"`

	// The type of the property
	Type BlocksElemStatesElemType `json:"type" yaml:"type" mapstructure:"type"`

	// The possible values of the property
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

type BlocksElemStatesElemType string

const BlocksElemStatesElemTypeBool BlocksElemStatesElemType = "bool"
const BlocksElemStatesElemTypeDirection BlocksElemStatesElemType = "direction"
const BlocksElemStatesElemTypeEnum BlocksElemStatesElemType = "enum"
const BlocksElemStatesElemTypeInt BlocksElemStatesElemType = "int"

var enumValues_BlocksElemStatesElemType = []interface{}{
	"enum",
	"bool",
	"int",
	"direction",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlocksElemStatesElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BlocksElemStatesElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BlocksElemStatesElemType, v)
	}
	*j = BlocksElemStatesElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlocksElemStatesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in BlocksElemStatesElem: required")
	}
	if _, ok := raw["num_values"]; raw != nil && !ok {
		return fmt.Errorf("field num_values in BlocksElemStatesElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in BlocksElemStatesElem: required")
	}
	type Plain BlocksElemStatesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlocksElemStatesElem(plain)
	return nil
}

type BlocksElemVariationsElem struct {
	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DisplayName corresponds to the JSON schema field "displayName".
	DisplayName string `json:"displayName" yaml:"displayName" mapstructure:"displayName"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata int `json:"metadata" yaml:"metadata" mapstructure:"metadata"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BlocksElemVariationsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["displayName"]; raw != nil && !ok {
		return fmt.Errorf("field displayName in BlocksElemVariationsElem: required")
	}
	if _, ok := raw["metadata"]; raw != nil && !ok {
		return fmt.Errorf("field metadata in BlocksElemVariationsElem: required")
	}
	type Plain BlocksElemVariationsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BlocksElemVariationsElem(plain)
	return nil
}
