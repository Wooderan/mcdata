// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import "encoding/json"
import "fmt"
import "reflect"

type ArgumentNode struct {
	// Children corresponds to the JSON schema field "children".
	Children []interface{} `json:"children" yaml:"children" mapstructure:"children"`

	// Executable corresponds to the JSON schema field "executable".
	Executable bool `json:"executable" yaml:"executable" mapstructure:"executable"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Parser corresponds to the JSON schema field "parser".
	Parser *ArgumentNodeParser `json:"parser,omitempty" yaml:"parser,omitempty" mapstructure:"parser,omitempty"`

	// Redirects corresponds to the JSON schema field "redirects".
	Redirects []string `json:"redirects" yaml:"redirects" mapstructure:"redirects"`

	// Type corresponds to the JSON schema field "type".
	Type ArgumentNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type ArgumentNodeParser struct {
	// Modifier corresponds to the JSON schema field "modifier".
	Modifier ArgumentNodeParserModifier `json:"modifier,omitempty" yaml:"modifier,omitempty" mapstructure:"modifier,omitempty"`

	// Parser corresponds to the JSON schema field "parser".
	Parser *string `json:"parser,omitempty" yaml:"parser,omitempty" mapstructure:"parser,omitempty"`
}

type ArgumentNodeParserModifier map[string]interface{}

type ArgumentNodeType string

const ArgumentNodeTypeArgument ArgumentNodeType = "argument"

var enumValues_ArgumentNodeType = []interface{}{
	"argument",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArgumentNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ArgumentNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ArgumentNodeType, v)
	}
	*j = ArgumentNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArgumentNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["children"]; raw != nil && !ok {
		return fmt.Errorf("field children in ArgumentNode: required")
	}
	if _, ok := raw["executable"]; raw != nil && !ok {
		return fmt.Errorf("field executable in ArgumentNode: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ArgumentNode: required")
	}
	if _, ok := raw["redirects"]; raw != nil && !ok {
		return fmt.Errorf("field redirects in ArgumentNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in ArgumentNode: required")
	}
	type Plain ArgumentNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ArgumentNode(plain)
	return nil
}

type CommandsSchema struct {
	// Graph corresponds to the JSON schema field "graph".
	Graph *RootNode `json:"graph,omitempty" yaml:"graph,omitempty" mapstructure:"graph,omitempty"`

	// Parsers corresponds to the JSON schema field "parsers".
	Parsers []ParserInfo `json:"parsers" yaml:"parsers" mapstructure:"parsers"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CommandsSchema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["parsers"]; raw != nil && !ok {
		return fmt.Errorf("field parsers in CommandsSchema: required")
	}
	type Plain CommandsSchema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CommandsSchema(plain)
	return nil
}

type LiteralNode struct {
	// Children corresponds to the JSON schema field "children".
	Children []interface{} `json:"children" yaml:"children" mapstructure:"children"`

	// Executable corresponds to the JSON schema field "executable".
	Executable bool `json:"executable" yaml:"executable" mapstructure:"executable"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Redirects corresponds to the JSON schema field "redirects".
	Redirects []string `json:"redirects" yaml:"redirects" mapstructure:"redirects"`

	// Type corresponds to the JSON schema field "type".
	Type LiteralNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type LiteralNodeType string

const LiteralNodeTypeLiteral LiteralNodeType = "literal"

var enumValues_LiteralNodeType = []interface{}{
	"literal",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LiteralNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LiteralNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LiteralNodeType, v)
	}
	*j = LiteralNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LiteralNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["children"]; raw != nil && !ok {
		return fmt.Errorf("field children in LiteralNode: required")
	}
	if _, ok := raw["executable"]; raw != nil && !ok {
		return fmt.Errorf("field executable in LiteralNode: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in LiteralNode: required")
	}
	if _, ok := raw["redirects"]; raw != nil && !ok {
		return fmt.Errorf("field redirects in LiteralNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in LiteralNode: required")
	}
	type Plain LiteralNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LiteralNode(plain)
	return nil
}

type ParserInfo struct {
	// Examples corresponds to the JSON schema field "examples".
	Examples []string `json:"examples" yaml:"examples" mapstructure:"examples"`

	// Modifier corresponds to the JSON schema field "modifier".
	Modifier ParserInfoModifier `json:"modifier" yaml:"modifier" mapstructure:"modifier"`

	// Parser corresponds to the JSON schema field "parser".
	Parser string `json:"parser" yaml:"parser" mapstructure:"parser"`
}

type ParserInfoModifier map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParserInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["examples"]; raw != nil && !ok {
		return fmt.Errorf("field examples in ParserInfo: required")
	}
	if _, ok := raw["modifier"]; raw != nil && !ok {
		return fmt.Errorf("field modifier in ParserInfo: required")
	}
	if _, ok := raw["parser"]; raw != nil && !ok {
		return fmt.Errorf("field parser in ParserInfo: required")
	}
	type Plain ParserInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ParserInfo(plain)
	return nil
}

type RootNode struct {
	// Children corresponds to the JSON schema field "children".
	Children []interface{} `json:"children" yaml:"children" mapstructure:"children"`

	// Executable corresponds to the JSON schema field "executable".
	Executable bool `json:"executable" yaml:"executable" mapstructure:"executable"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Redirects corresponds to the JSON schema field "redirects".
	Redirects []string `json:"redirects" yaml:"redirects" mapstructure:"redirects"`

	// Type corresponds to the JSON schema field "type".
	Type RootNodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type RootNodeType string

const RootNodeTypeRoot RootNodeType = "root"

var enumValues_RootNodeType = []interface{}{
	"root",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RootNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RootNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RootNodeType, v)
	}
	*j = RootNodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RootNode) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["children"]; raw != nil && !ok {
		return fmt.Errorf("field children in RootNode: required")
	}
	if _, ok := raw["executable"]; raw != nil && !ok {
		return fmt.Errorf("field executable in RootNode: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RootNode: required")
	}
	if _, ok := raw["redirects"]; raw != nil && !ok {
		return fmt.Errorf("field redirects in RootNode: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in RootNode: required")
	}
	type Plain RootNode
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RootNode(plain)
	return nil
}
