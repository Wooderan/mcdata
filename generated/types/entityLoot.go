// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package types

import "encoding/json"
import "fmt"

type EntityLoot []struct {
	// The list of item drops
	Drops []EntityLootElemDropsElem `json:"drops" yaml:"drops" mapstructure:"drops"`

	// The name of the entity
	Entity string `json:"entity" yaml:"entity" mapstructure:"entity"`
}

type EntityLootElemDropsElem struct {
	// The percent chance of the item drop to occur
	DropChance float64 `json:"dropChance" yaml:"dropChance" mapstructure:"dropChance"`

	// The name of the item being dropped
	Item string `json:"item" yaml:"item" mapstructure:"item"`

	// The metadata of the item being dropped (Bedrock Edition)
	Metadata *int `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// If a player killer is required
	PlayerKill *bool `json:"playerKill,omitempty" yaml:"playerKill,omitempty" mapstructure:"playerKill,omitempty"`

	// The min/max of number of items in this item drop stack
	StackSizeRange []*float64 `json:"stackSizeRange" yaml:"stackSizeRange" mapstructure:"stackSizeRange"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EntityLootElemDropsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["dropChance"]; raw != nil && !ok {
		return fmt.Errorf("field dropChance in EntityLootElemDropsElem: required")
	}
	if _, ok := raw["item"]; raw != nil && !ok {
		return fmt.Errorf("field item in EntityLootElemDropsElem: required")
	}
	if _, ok := raw["stackSizeRange"]; raw != nil && !ok {
		return fmt.Errorf("field stackSizeRange in EntityLootElemDropsElem: required")
	}
	type Plain EntityLootElemDropsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EntityLootElemDropsElem(plain)
	return nil
}
